Virtuelle Methoden

Durch das Ableiten von Klassen ergibt sich auch die so genannte Polymorphie. Jede Klasse repräsentiert einen eigenen Datentyp. Abgeleitete Klassen haben mindestens einen weiteren Datentyp, nämlich den der Basisklasse (auch als Oberklasse oder Superklasse bezeichnet). Dadurch ist es zum Beispiel möglich, eine Liste von Objekten der Klasse A zu benutzen, obwohl in Wirklichkeit auch Objekte der Klasse B (die von A abgeleitet wurde) in der Liste abgelegt sind.

Problematik
Ein Compiler versucht während der Übersetzung, für jede aufgerufene Funktion eine Adresse im Speicher festzulegen, an der eine Funktion oder Methode beginnt. Im späteren Programm wird die CPU bei einem Aufruf die entsprechende Adresse anspringen und weiterarbeiten (daneben wird noch einige administrative Arbeit notwendig, die hier nicht weiter von Bedeutung ist). Bei abgeleiteten Klassen mit überschriebenen oder überladenen Methoden ist jedoch nicht immer zur Übersetzungszeit bekannt, welche Methode aufzurufen ist. Im Beispiel mit der Liste (s. u.) kann der Übersetzer zum Beispiel nicht immer wissen, wann andere Objekte als Objekte vom Typ A in der Liste auftauchen.

Lösung
Eine Lösung ist die indirekte Adressierung über eine Tabelle. Kann der Übersetzer nicht feststellen, welche Methode angesprungen werden soll, wird nicht eine Einsprungadresse angegeben, sondern nur ein Verweis auf einen Eintrag in der virtuellen Tabelle abgelegt. Darin stehen die konkreten Einsprungadressen, die während des Programmlaufs angesprungen werden sollen.

Bsp

# include <iostream>
using namespace std;
 
class Tier
{
public:
    virtual void essen() = 0; // Rein virtuelle Methode
};
 
class Wolf : public Tier
{
public:
    void essen() { cout << "Wölfe können essen!" << endl; } // Implementierung der virtuellen Methode
};
 
int main()
{
    Wolf wolf1;
    wolf1.essen(); // OK
}
